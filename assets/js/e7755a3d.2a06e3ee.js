"use strict";(self.webpackChunkmongez_docs=self.webpackChunkmongez_docs||[]).push([[8688],{1382:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>d,toc:()=>m});var r=t(4848),s=t(5680),o=t(1470),a=t(9365);const i={sidebar_position:2},c="Embedded Documents",d={id:"cascade/relationships/embedded-documents",title:"Embedded Documents",description:"Embedded documents concept is a core feature of MongoDB, and it is very useful when you want to store related data in the same document. This is a very common practice in MongoDB, and it is called Embedded Relationships.",source:"@site/docs/cascade/relationships/embedded-documents.mdx",sourceDirName:"cascade/relationships",slug:"/cascade/relationships/embedded-documents",permalink:"/docs/cascade/relationships/embedded-documents",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"mongodb",previous:{title:"Introduction",permalink:"/docs/cascade/relationships/introduction"},next:{title:"Syncing Models",permalink:"/docs/cascade/relationships/syncing-models"}},l={},m=[{value:"Embedding Documents",id:"embedding-documents",level:2},{value:"Embedding Single Document",id:"embedding-single-document",level:3},{value:"Specifying the Embedded Data",id:"specifying-the-embedded-data",level:3},{value:"Embedding Multiple Documents",id:"embedding-multiple-documents",level:3},{value:"Associating Documents",id:"associating-documents",level:3},{value:"Re-Associating Documents",id:"re-associating-documents",level:3},{value:"Disassociating Documents",id:"disassociating-documents",level:3}];function u(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.RP)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"embedded-documents",children:"Embedded Documents"}),"\n",(0,r.jsxs)(n.p,{children:["Embedded documents concept is a core feature of MongoDB, and it is very useful when you want to store related data in the same document. This is a very common practice in MongoDB, and it is called ",(0,r.jsx)(n.strong,{children:"Embedded Relationships"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["It makes the query faster because when we fetch the post we don't have to lookup the ",(0,r.jsx)(n.code,{children:"users"})," collection to get the author's data, it is already there."]}),"\n",(0,r.jsx)(n.p,{children:"Before we continue, Let's create three models that we'll use in all of our examples"}),"\n",(0,r.jsxs)(o.A,{children:[(0,r.jsx)(a.A,{value:"user",label:"User Model",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:"src/app/models/user.ts",children:'import { Model, Casts } from "@warlock.js/cascade";\r\n\r\nexport class User extends Model {\r\n  /**\r\n   * Collection name\r\n   */\r\n  public static collection = "users";\r\n\r\n  /**\r\n   * {@inheritDoc}\r\n   */\r\n  protected casts: Casts = {\r\n    name: "string",\r\n    image: "string",\r\n    email: "string",\r\n    password: "string",\r\n  };\r\n}\n'})})}),(0,r.jsx)(a.A,{value:"comment",label:"Comment Model",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:"src/app/models/comment.ts",children:'import { Model, Casts } from "@warlock.js/cascade";\r\n\r\nexport class Comment extends Model {\r\n  /**\r\n   * Collection name\r\n   */\r\n  public static collection = "comments";\r\n\r\n  /**\r\n   * {@inheritDoc}\r\n   */\r\n  protected casts: Casts = {\r\n    comment: "string",\r\n    createdBy: "object",\r\n  };\r\n}\n'})})}),(0,r.jsx)(a.A,{value:"post",label:"Post Model",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:"src/app/models/post.ts{15,16}",children:'import { Model, Casts } from "@warlock.js/cascade";\r\n\r\nexport class Post extends Model {\r\n  /**\r\n   * Collection name\r\n   */\r\n  public static collection = "posts";\r\n\r\n  /**\r\n   * {@inheritDoc}\r\n   */\r\n  protected casts: Casts = {\r\n    title: "string",\r\n    content: "string",\r\n    author: "object", // user object\r\n    comments: "array", // array of comments\r\n  };\r\n}\n'})})})]}),"\n",(0,r.jsx)(n.h2,{id:"embedding-documents",children:"Embedding Documents"}),"\n",(0,r.jsx)(n.p,{children:"There are two types of embedded documents:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Embedding Single document"}),"\n",(0,r.jsx)(n.li,{children:"Embedding Multiple documents"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"embedding-single-document",children:"Embedding Single Document"}),"\n",(0,r.jsxs)(n.p,{children:["Consider embedding single document as a ",(0,r.jsx)(n.code,{children:"hasOne"})," relationship in SQL databases, where the document contains only one embedded document."]}),"\n",(0,r.jsxs)(n.p,{children:["For example, the post has an ",(0,r.jsx)(n.code,{children:"author"})," so the author will be embedded inside the post document as a single document, for example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\r\n  "id": 1,\r\n  "title": "Hello World",\r\n  "content": "This is the post body",\r\n  "author": {\r\n    "id": 5122,\r\n    "name": "John Doe",\r\n    "image": "https://example.com/image.jpg"\r\n  }\r\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Let's see how we can achieve this using models"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:"src/app.ts {13}",children:'import { Post } from "./models/post";\r\nimport { User } from "./models/user";\r\n\r\nasync function main() {\r\n  const author = await User.create({\r\n    name: "John Doe",\r\n    image: "https://example.com/image.jpg",\r\n  });\r\n\r\n  const post = await Post.create({\r\n    title: "Hello World",\r\n    content: "This is the post body",\r\n    author: author.embeddedData, // embed the author data\r\n  });\r\n}\r\n\r\nmain();\n'})}),"\n",(0,r.jsxs)(n.p,{children:["What we've done here is we created a new user, which is basically a very simple operation, then we created a new post and we embedded the author's data inside the post document using the ",(0,r.jsx)(n.code,{children:"embeddedData"})," property."]}),"\n",(0,r.jsx)(n.p,{children:"The data of the author that will be stored will be the following:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\r\n  "id": 5122,\r\n  "name": "John Doe",\r\n  "image": "https://example.com/image.jpg",\r\n  "createdAt": "2023-01-01T00:00:00.000Z",\r\n  "updatedAt": "2023-01-01T00:00:00.000Z"\r\n}\n'})}),"\n",(0,r.jsx)(n.admonition,{title:"Did you know?",type:"tip",children:(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"embeddedData"})," property is a getter that returns the embedded data of the model, it is used internally by the model to embed the data, if you do not override it, it will return the whole model data. Thus, you ",(0,r.jsx)(n.strong,{children:"should override"})," it to return only the data you want to embed."]})}),"\n",(0,r.jsx)(n.h3,{id:"specifying-the-embedded-data",children:"Specifying the Embedded Data"}),"\n",(0,r.jsxs)(n.p,{children:["As mentioned earlier, using ",(0,r.jsx)(n.code,{children:"embeddedData"})," property will embed the whole model data, but what if you want to embed only the ",(0,r.jsx)(n.code,{children:"id"}),", ",(0,r.jsx)(n.code,{children:"name"})," and ",(0,r.jsx)(n.code,{children:"image"})," of the author?"]}),"\n",(0,r.jsxs)(n.p,{children:["Well, let's then update our ",(0,r.jsx)(n.code,{children:"User"})," model to return only the data we want to embed"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:"src/app/models/user.ts{22,23,24}",children:'import { Model, Casts } from "@warlock.js/cascade";\r\n\r\nexport class User extends Model {\r\n  /**\r\n   * Collection name\r\n   */\r\n  public static collection = "users";\r\n\r\n  /**\r\n   * {@inheritDoc}\r\n   */\r\n  protected casts: Casts = {\r\n    name: "string",\r\n    image: "string",\r\n    email: "string",\r\n    password: "string",\r\n  };\r\n\r\n  /**\r\n   * {@inheritDoc}\r\n   */\r\n  public get embeddedData() {\r\n    return this.only(["id", "name", "image"]);\r\n  }\r\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"This will reduce the embedded documents when we embed the user data inside the post document to the following:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\r\n  "id": 5122,\r\n  "name": "John Doe",\r\n  "image": "https://example.com/image.jpg"\r\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Another way to define the embedded columns is by defining the ",(0,r.jsx)(n.code,{children:"embedded"})," property, it is an array of columns that will be embedded, for example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:"src/app/models/user.ts{22}",children:'import { Model, Casts } from "@warlock.js/cascade";\r\n\r\nexport class User extends Model {\r\n  /**\r\n   * Collection name\r\n   */\r\n  public static collection = "users";\r\n\r\n  /**\r\n   * {@inheritDoc}\r\n   */\r\n  protected casts: Casts = {\r\n    name: "string",\r\n    image: "string",\r\n    email: "string",\r\n    password: "string",\r\n  };\r\n\r\n  /**\r\n   * {@inheritDoc}\r\n   */\r\n  public embedded = ["id", "name", "image"];\r\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"That's how we can embed single documents, let's now see how we can embed multiple documents."}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["When using ",(0,r.jsx)(n.a,{href:"./../models/casting-data#castmodel",children:"castModel"}),", the ",(0,r.jsx)(n.code,{children:"embeddedData"})," property will be used to embed the data, so you don't have to worry about it."]})}),"\n",(0,r.jsx)(n.h3,{id:"embedding-multiple-documents",children:"Embedding Multiple Documents"}),"\n",(0,r.jsx)(n.p,{children:"Embedding multiple documents is basically adding list of documents inside one column of a parent document, for example we can insert list of comments inside a single post"}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["It's not ",(0,r.jsx)(n.strong,{children:"recommended"})," to store large documents like comments inside a single post, if the post has a lot of comments, it will be very slow to retrieve the post data, instead you should use ",(0,r.jsx)(n.strong,{children:"referencing documents"})," to store the comments in a separate collection."]})}),"\n",(0,r.jsx)(n.h3,{id:"associating-documents",children:"Associating Documents"}),"\n",(0,r.jsxs)(n.p,{children:["To associate documents, we use the ",(0,r.jsx)(n.code,{children:"associate"})," method, it takes three arguments:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"The column name"}),"\n",(0,r.jsx)(n.li,{children:"The model class"}),"\n",(0,r.jsxs)(n.li,{children:["the embedded property name, default to ",(0,r.jsx)(n.code,{children:"embeddedData"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Let's see an example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:"src/app.ts {25}",children:'import { Post } from "./models/post";\r\nimport { User } from "./models/user";\r\nimport { Comment } from "./models/comment";\r\n\r\nasync function main() {\r\n  const author = await User.create({\r\n    name: "John Doe",\r\n    image: "https://example.com/image.jpg",\r\n  });\r\n\r\n  // now let\'s create a new post model\r\n  const post = new Post({\r\n    title: "Hello World",\r\n    content: "This is the post body",\r\n    author: author.embeddedData,\r\n  });\r\n\r\n  // create new comment\r\n  const comment = await Comment.create({\r\n    content: "This is a comment",\r\n    createdBy: author.embeddedData,\r\n  });\r\n\r\n  // let\'s add that comment to the post\r\n  post.associate("comments", comment);\r\n\r\n  post.save();\r\n}\r\n\r\nmain();\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This will inject the comment into our post in ",(0,r.jsx)(n.code,{children:"comments"})," column, we can specify the embedded property name by passing the third argument to the ",(0,r.jsx)(n.code,{children:"associate"})," method"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:"src/app.ts {25}",children:'import { Post } from "./models/post";\r\nimport { User } from "./models/user";\r\nimport { Comment } from "./models/comment";\r\n\r\nasync function main() {\r\n  const author = await User.create({\r\n    name: "John Doe",\r\n    image: "https://example.com/image.jpg",\r\n  });\r\n\r\n  // now let\'s create a new post model\r\n  const post = new Post({\r\n    title: "Hello World",\r\n    content: "This is the post body",\r\n    author: author.embeddedData,\r\n  });\r\n\r\n  // create new comment\r\n  const comment = await Comment.create({\r\n    content: "This is a comment",\r\n    createdBy: author.embeddedData,\r\n  });\r\n\r\n  // let\'s add that comment to the post\r\n  post.associate("comments", comment, "embedToPost");\r\n\r\n  post.save();\r\n}\r\n\r\nmain();\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Let's define that ",(0,r.jsx)(n.code,{children:"embedToPost"})," property in our ",(0,r.jsx)(n.code,{children:"Comment"})," model"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:"src/app/models/comment.ts {28}",children:'import { Model, Casts } from "@warlock.js/cascade";\r\n\r\nexport class Comment extends Model {\r\n  /**\r\n   * Collection name\r\n   */\r\n  public static collection = "comments";\r\n\r\n  /**\r\n   * {@inheritDoc}\r\n   */\r\n  protected casts: Casts = {\r\n    content: "string",\r\n    createdBy: "object",\r\n  };\r\n\r\n  /**\r\n   * {@inheritDoc}\r\n   */\r\n  public get embeddedData() {\r\n    return this.only(["id", "content", "createdBy"]);\r\n  }\r\n\r\n  /**\r\n   * {@inheritDoc}\r\n   */\r\n  public get embedToPost() {\r\n    return this.only(["id", "content", "createdBy", "createdAt"]);\r\n  }\r\n}\n'})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["If the ",(0,r.jsx)(n.code,{children:"comments"})," field does not exist, it will be created automatically"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"re-associating-documents",children:"Re-Associating Documents"}),"\n",(0,r.jsxs)(n.p,{children:["Consider the ",(0,r.jsx)(n.code,{children:"reassociate"})," method as an update for the document inside the parent document, for example, if the comment's data is updated, we can re-associate it to the post to update the comment data inside the post"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:"src/app.ts {14}",children:'import { Post } from "./models/post";\r\nimport { User } from "./models/user";\r\nimport { Comment } from "./models/comment";\r\n\r\nasync function main() {\r\n  const comment = await Comment.find(1);\r\n\r\n  comment.set("comment", "a new comment");\r\n\r\n  comment.save();\r\n\r\n  const post = await Post.find(1);\r\n\r\n  post.reassociate("comments", comment);\r\n\r\n  post.save();\r\n}\r\n\r\nmain();\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"reassociate"})," method does multiple things, first off, it checks is the ",(0,r.jsx)(n.code,{children:"comments"})," field exists, if not then it creates a new one, then it checks if the comment exists inside the ",(0,r.jsx)(n.code,{children:"comments"})," field, if not then it pushes it to the ",(0,r.jsx)(n.code,{children:"comments"})," field, if it exists then it updates the comment data inside the ",(0,r.jsx)(n.code,{children:"comments"})," field in the same index."]}),"\n",(0,r.jsxs)(n.p,{children:["You may also pass the third argument to the ",(0,r.jsx)(n.code,{children:"reassociate"})," method to specify the embedded property name"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:"src/app.ts {14}",children:'import { Post } from "./models/post";\r\nimport { User } from "./models/user";\r\nimport { Comment } from "./models/comment";\r\n\r\nasync function main() {\r\n  const comment = await Comment.find(1);\r\n\r\n  comment.set("comment", "a new comment");\r\n\r\n  comment.save();\r\n\r\n  const post = await Post.find(1);\r\n\r\n  post.reassociate("comments", comment, "embedToPost");\r\n\r\n  post.save();\r\n}\r\n\r\nmain();\n'})}),"\n",(0,r.jsx)(n.admonition,{title:"Did you know?",type:"tip",children:(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"reassociate"})," method can work exactly like the ",(0,r.jsx)(n.code,{children:"associate"})," method, so you can use it to associate new documents to the parent document, but its always ",(0,r.jsx)(n.strong,{children:"recommended"})," to use the ",(0,r.jsx)(n.code,{children:"associate"})," method to associate new documents."]})}),"\n",(0,r.jsx)(n.h3,{id:"disassociating-documents",children:"Disassociating Documents"}),"\n",(0,r.jsxs)(n.p,{children:["I guess you already know what the ",(0,r.jsx)(n.code,{children:"disassociate"})," method does, it removes the document from the parent document, let's see an example"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:"src/app.ts {13}",children:'import { Post } from "./models/post";\r\nimport { User } from "./models/user";\r\nimport { Comment } from "./models/comment";\r\n\r\nasync function main() {\r\n  const comment = await Comment.find(1);\r\n\r\n  const post = await Post.find(1);\r\n\r\n  post.reassociate("comments", comment);\r\n\r\n  // now let\'s disassociate (remove) the comment from the post\r\n  post.disassociate("comments", comment);\r\n\r\n  post.save();\r\n}\r\n\r\nmain();\n'})}),"\n",(0,r.jsx)(n.admonition,{title:"Embedded Objects",type:"info",children:(0,r.jsxs)(n.p,{children:["Any one of the three methods, should receive the embedded model as second argument, but you may also pass any type of data, for example the field could be an array of strings, or an array of numbers, if the second argument is an object, the methods will look for ",(0,r.jsx)(n.code,{children:"id"})," inside it as a unique identifier, if it's not found, then it will search by the entire value regardless of the type, if not found in ",(0,r.jsx)(n.code,{children:"reassociate"})," method, then it will push it to the array, if not found in ",(0,r.jsx)(n.code,{children:"disassociate"})," method, then it will do nothing."]})})]})}function h(e={}){const{wrapper:n}={...(0,s.RP)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},5680:(e,n,t)=>{t.d(n,{RP:()=>d});var r=t(6540);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,s=function(e,n){if(null==e)return{};var t,r,s={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var c=r.createContext({}),d=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},l={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,s=e.mdxType,o=e.originalType,c=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),u=d(t),h=s,p=u["".concat(c,".").concat(h)]||u[h]||l[h]||o;return t?r.createElement(p,a(a({ref:n},m),{},{components:t})):r.createElement(p,a({ref:n},m))}));m.displayName="MDXCreateElement"},9365:(e,n,t)=>{t.d(n,{A:()=>a});t(6540);var r=t(8215);const s={tabItem:"tabItem_Ymn6"};var o=t(4848);function a(e){let{children:n,hidden:t,className:a}=e;return(0,o.jsx)("div",{role:"tabpanel",className:(0,r.A)(s.tabItem,a),hidden:t,children:n})}},1470:(e,n,t)=>{t.d(n,{A:()=>v});var r=t(6540),s=t(8215),o=t(3104),a=t(6347),i=t(205),c=t(7485),d=t(1682),l=t(9466);function m(e){return r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:n,children:t}=e;return(0,r.useMemo)((()=>{const e=n??function(e){return m(e).map((e=>{let{props:{value:n,label:t,attributes:r,default:s}}=e;return{value:n,label:t,attributes:r,default:s}}))}(t);return function(e){const n=(0,d.X)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function h(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function p(e){let{queryString:n=!1,groupId:t}=e;const s=(0,a.W6)(),o=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,c.aZ)(o),(0,r.useCallback)((e=>{if(!o)return;const n=new URLSearchParams(s.location.search);n.set(o,e),s.replace({...s.location,search:n.toString()})}),[o,s])]}function g(e){const{defaultValue:n,queryString:t=!1,groupId:s}=e,o=u(e),[a,c]=(0,r.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!h({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const r=t.find((e=>e.default))??t[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:o}))),[d,m]=p({queryString:t,groupId:s}),[g,b]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[s,o]=(0,l.Dv)(t);return[s,(0,r.useCallback)((e=>{t&&o.set(e)}),[t,o])]}({groupId:s}),f=(()=>{const e=d??g;return h({value:e,tabValues:o})?e:null})();(0,i.A)((()=>{f&&c(f)}),[f]);return{selectedValue:a,selectValue:(0,r.useCallback)((e=>{if(!h({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);c(e),m(e),b(e)}),[m,b,o]),tabValues:o}}var b=t(2303);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var x=t(4848);function j(e){let{className:n,block:t,selectedValue:r,selectValue:a,tabValues:i}=e;const c=[],{blockElementScrollPositionUntilNextRender:d}=(0,o.a_)(),l=e=>{const n=e.currentTarget,t=c.indexOf(n),s=i[t].value;s!==r&&(d(n),a(s))},m=e=>{let n=null;switch(e.key){case"Enter":l(e);break;case"ArrowRight":{const t=c.indexOf(e.currentTarget)+1;n=c[t]??c[0];break}case"ArrowLeft":{const t=c.indexOf(e.currentTarget)-1;n=c[t]??c[c.length-1];break}}n?.focus()};return(0,x.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":t},n),children:i.map((e=>{let{value:n,label:t,attributes:o}=e;return(0,x.jsx)("li",{role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,ref:e=>c.push(e),onKeyDown:m,onClick:l,...o,className:(0,s.A)("tabs__item",f.tabItem,o?.className,{"tabs__item--active":r===n}),children:t??n},n)}))})}function y(e){let{lazy:n,children:t,selectedValue:s}=e;const o=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=o.find((e=>e.props.value===s));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return(0,x.jsx)("div",{className:"margin-top--md",children:o.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==s})))})}function w(e){const n=g(e);return(0,x.jsxs)("div",{className:(0,s.A)("tabs-container",f.tabList),children:[(0,x.jsx)(j,{...n,...e}),(0,x.jsx)(y,{...n,...e})]})}function v(e){const n=(0,b.A)();return(0,x.jsx)(w,{...e,children:m(e.children)},String(n))}}}]);