"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2972],{7944:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var r=t(4848),s=t(8453);const a={sidebar_position:8},o="Saving Models",i={id:"cascade/models/saving-models",title:"Saving Models",description:"Introduction",source:"@site/docs/cascade/models/saving-models.mdx",sourceDirName:"cascade/models",slug:"/cascade/models/saving-models",permalink:"/docs/cascade/models/saving-models",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"mongodb",previous:{title:"Embedded documents",permalink:"/docs/cascade/models/embedded-documents"},next:{title:"Destroying Models",permalink:"/docs/cascade/models/destroying-models"}},d={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Types of saved models",id:"types-of-saved-models",level:2},{value:"New models",id:"new-models",level:3},{value:"Existing models",id:"existing-models",level:3},{value:"Passing more data when saving model",id:"passing-more-data-when-saving-model",level:2},{value:"Disable castings",id:"disable-castings",level:2},{value:"Model Events",id:"model-events",level:2},{value:"Silent Saving",id:"silent-saving",level:2},{value:"Manually Generating the next ID",id:"manually-generating-the-next-id",level:2},{value:"Timestamps",id:"timestamps",level:2},{value:"Upsert",id:"upsert",level:2},{value:"A note about saving models",id:"a-note-about-saving-models",level:2}];function l(e){const n={admonition:"admonition",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"saving-models",children:"Saving Models"}),"\n",(0,r.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsx)(n.p,{children:"In previous sections, we saw how to save models using multiple ways, so let's go more in depth here."}),"\n",(0,r.jsx)(n.h2,{id:"types-of-saved-models",children:"Types of saved models"}),"\n",(0,r.jsx)(n.p,{children:"We have two types of saved models: the new models and the existing models."}),"\n",(0,r.jsx)(n.h3,{id:"new-models",children:"New models"}),"\n",(0,r.jsx)(n.p,{children:"We already discussed and saw to how to save new models, so let's take a quick example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/app.ts"',children:'import { Category } from "./models/category";\r\n\r\nasync function main() {\r\n  const category = new Category({\r\n    name: "Sports",\r\n    isActive: true,\r\n  });\r\n\r\n  await category.save();\r\n\r\n  // or\r\n\r\n  const category2 = await Category.create({\r\n    name: "Sports",\r\n    isActive: true,\r\n  });\r\n}\r\n\r\nmain();\n'})}),"\n",(0,r.jsxs)(n.p,{children:["So if we used the static method ",(0,r.jsx)(n.code,{children:"create"})," it will create a new model and save it or we can do it in two steps by creating a new model and then save it."]}),"\n",(0,r.jsx)(n.h3,{id:"existing-models",children:"Existing models"}),"\n",(0,r.jsxs)(n.p,{children:["We can save existing models by using the ",(0,r.jsx)(n.code,{children:"save"})," method, let's take an example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/app.ts"',children:'import { Category } from "./models/category";\r\n\r\nasync function main() {\r\n  const category = await Category.find(1);\r\n\r\n  if (!category) return;\r\n\r\n  category.set("name", "Sports");\r\n\r\n  await category.save();\r\n}\r\n\r\nmain();\n'})}),"\n",(0,r.jsx)(n.p,{children:"So here we are updating the category name and then save it."}),"\n",(0,r.jsxs)(n.p,{children:["We can also use the static method ",(0,r.jsx)(n.code,{children:"update"})," to update a model:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/app.ts"',children:'import { Category } from "./models/category";\r\n\r\nasync function main() {\r\n  const category = await Category.update(1, {\r\n    name: "Sports",\r\n  });\r\n}\r\n\r\nmain();\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This will update the category with the id ",(0,r.jsx)(n.code,{children:"1"})," and set the name to ",(0,r.jsx)(n.code,{children:"Sports"})," then returns the updated model instance."]}),"\n",(0,r.jsx)(n.h2,{id:"passing-more-data-when-saving-model",children:"Passing more data when saving model"}),"\n",(0,r.jsx)(n.p,{children:"We can pass more data when saving a model, let's take an example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/app.ts"',children:'import { Category } from "./models/category";\r\n\r\nasync function main() {\r\n  const category = await Category.find(1);\r\n\r\n  if (!category) return;\r\n\r\n  category.set("name", "Sports");\r\n\r\n  await category.save({\r\n    refresh: true,\r\n  });\r\n}\r\n\r\nmain();\n'})}),"\n",(0,r.jsxs)(n.p,{children:["So here we are passing an object to the ",(0,r.jsx)(n.code,{children:"save"})," method, that we added the ",(0,r.jsx)(n.code,{children:"refresh"})," property to it and set it to ",(0,r.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"disable-castings",children:"Disable castings"}),"\n",(0,r.jsxs)(n.p,{children:["In some situations we need to save the model but without triggering the casts, this could be useful if we're updating the model using model events but we need to update only partial data, in this case we can pass to the second argument of the save method ",(0,r.jsx)(n.code,{children:"cast"})," property with false value, let's take an example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/app.ts"',children:'import { Category } from "./models/category";\r\n\r\nasync function main() {\r\n  const category = await Category.find(1);\r\n\r\n  if (!category) return;\r\n\r\n  category.set("name", "Sports");\r\n\r\n  await category.save(\r\n    {},\r\n    {\r\n      cast: false,\r\n    }\r\n  );\r\n}\r\n\r\nmain();\n'})}),"\n",(0,r.jsx)(n.h2,{id:"model-events",children:"Model Events"}),"\n",(0,r.jsxs)(n.p,{children:["The Model is shipped with powerful events system that allows you to fully interact with model actions, like ",(0,r.jsx)(n.code,{children:"onCreating"}),", ",(0,r.jsx)(n.code,{children:"onUpdating"}),", ",(0,r.jsx)(n.code,{children:"onSaving"}),", ",(0,r.jsx)(n.code,{children:"onCreated"}),", ",(0,r.jsx)(n.code,{children:"onUpdated"}),", ",(0,r.jsx)(n.code,{children:"onSaved"})," and many more events, let's take an example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/app/main.ts"',children:'import { Category } from "./models/category";\r\n\r\nCategory.events()\r\n  .onCreating((category) => {\r\n    console.log("Category is being created");\r\n  })\r\n  .onUpdating((category, oldCategory) => {\r\n    console.log("Category is being updated");\r\n  })\r\n  .onSaving((category, oldCategory) => {\r\n    if (oldCategory) {\r\n      console.log("Category is being updated");\r\n    } else {\r\n      console.log("Category is being created");\r\n    }\r\n  })\r\n  .onCreated((category) => {\r\n    console.log("Category is created");\r\n  })\r\n  .onUpdated((category, oldCategory) => {\r\n    console.log("Category is updated");\r\n  })\r\n  .onSaved((category, oldCategory) => {\r\n    console.log("Category is saved");\r\n  })\r\n  .onDeleting((category) => {\r\n    console.log("Category is being deleted");\r\n  })\r\n  .onDeleted((category) => {\r\n    console.log("Category is deleted");\r\n  });\n'})}),"\n",(0,r.jsx)(n.p,{children:"This gives us a quick overview of the events system, now let's see a real world example."}),"\n",(0,r.jsxs)(n.p,{children:["If we're working with an ",(0,r.jsx)(n.code,{children:"Ecommerce"}),", we may need to count total products in each category whenever a product is created, updated or deleted, so we can do this using the model events, let's take an example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/app/main.ts"',children:'import { Category } from "./models/category";\r\nimport { Product } from "./models/product";\r\n\r\n// we need to count the number of products in the category each time a product is updated, created or deleted\r\nProduct.events()\r\n  .onSaved((product, oldProduct) => {\r\n    // because onSaved event works in both create and update actions\r\n    // if we want to know what is the current action, check the oldProduct parameter\r\n    // if it\'s undefined then it\'s a create action, otherwise it\'s an update action\r\n    calculateCategoryProducts(product.get("category.id"));\r\n\r\n    // if the product\'s category is changed, we need also to recount the products in the old category\r\n    if (\r\n      oldProduct &&\r\n      oldProduct.get("category.id") !== product.get("category.id")\r\n    ) {\r\n      calculateCategoryProducts(oldProduct.get("category.id"));\r\n    }\r\n  })\r\n  .onDeleted((product) => {\r\n    calculateCategoryProducts(product.get("category.id"));\r\n  });\r\n\r\nasync function calculateCategoryProducts(categoryId) {\r\n  const count = await Product.count({\r\n    "category.id": categoryId,\r\n  });\r\n\r\n  await Category.update(categoryId, {\r\n    productsCount: count,\r\n  });\r\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The good thing about events that, it is split into two types, ",(0,r.jsx)(n.code,{children:"synchronous"})," and ",(0,r.jsx)(n.code,{children:"asynchronous"})," events, for example any event that is triggered before the actual action is called, it will be acted as ",(0,r.jsx)(n.code,{children:"synchronous"})," event, because the model will wait until all event listeners are done, for example, we want to add before saving the product the product slug, we can use it just before the product is being saved, in that sense, the model will wait until the event is fully finished then proceed with the saving process, let's take an example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/app/main.ts"',children:'import { Product } from "./models/product";\r\n\r\nProduct.events().onSaving((product) => {\r\n  product.set("slug", product.get("name").toLowerCase().replace(/ /g, "-"));\r\n});\n'})}),"\n",(0,r.jsxs)(n.p,{children:["On the other hand, all events that are triggered after the action like ",(0,r.jsx)(n.code,{children:"onSaved"})," event, it will be acted as ",(0,r.jsx)(n.code,{children:"asynchronous"})," event, because there are no need to wait for it until the event listeners are fully called."]}),"\n",(0,r.jsxs)(n.p,{children:["This is the perfect behavior based on what you want to do, in our previous example, after the product is created, updated or deleted we want to update total products in the category, this process does not need to be ",(0,r.jsx)(n.code,{children:"waited"})," until its done so it takes place after the action is done and is not being ",(0,r.jsx)(n.code,{children:"awaited"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"silent-saving",children:"Silent Saving"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"silentSaving"})," method works exactly like ",(0,r.jsx)(n.code,{children:"save"})," method except that, it does not trigger any events, let's take an example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/app.ts"',children:'import { Category } from "./models/category";\r\n\r\nCategory.events().onSaving((category) => {\r\n  console.log(\r\n    "Category is being saved but it will not be called when calling silentSaving method."\r\n  );\r\n});\r\n\r\nasync function main() {\r\n  const category = await Category.find(1);\r\n\r\n  if (!category) return;\r\n\r\n  category.set("name", "Sports");\r\n\r\n  await category.silentSaving();\r\n}\r\n\r\nmain();\n'})}),"\n",(0,r.jsx)(n.p,{children:"This method is useful when we want to perform saving models without the need to trigger the events again."}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Use this method when you're working on the same saved model, otherwise it will go into an infinite loop."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Let's say for example, we have a ",(0,r.jsx)(n.code,{children:"quiz"})," for grade ",(0,r.jsx)(n.code,{children:"A"})," model where it has the ",(0,r.jsx)(n.code,{children:"autoSelectQuestions"})," field with ",(0,r.jsx)(n.code,{children:"true"}),", in that sense after the quiz is saved, we want to fetch all questions for grade ",(0,r.jsx)(n.code,{children:"A"})," then saves these questions into the ",(0,r.jsx)(n.code,{children:"quiz"})," again."]}),"\n",(0,r.jsxs)(n.p,{children:["Because this action will happen after the quiz is ",(0,r.jsx)(n.strong,{children:"saved"})," and we will save again the quiz with the questions list, we don't want to trigger the ",(0,r.jsx)(n.code,{children:"onSaved"})," event again, so we can use the ",(0,r.jsx)(n.code,{children:"silentSaving"})," method."]}),"\n",(0,r.jsx)(n.p,{children:"Let's take an example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/app.ts"',children:'import { Quiz } from "./models/quiz";\r\nimport { Question } from "./models/question";\r\n\r\nQuiz.events().onSaved(async (quiz) => {\r\n  if (quiz.get("autoSelectQuestions")) {\r\n    const questions = await Question.find({\r\n      grade: quiz.get("grade"),\r\n    });\r\n\r\n    await quiz.silentSaving({\r\n      questions,\r\n    });\r\n  }\r\n});\n'})}),"\n",(0,r.jsx)(n.h2,{id:"manually-generating-the-next-id",children:"Manually Generating the next ID"}),"\n",(0,r.jsxs)(n.p,{children:["In some scenarios, you might need to generate the next id even before saving the model, to achieve this we can use the ",(0,r.jsx)(n.code,{children:"generateNextId"})," method, let's take an example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/app.ts"',children:'import { Category } from "./models/category";\r\n\r\nasync function main() {\r\n  const category = new Category({\r\n    name: "Sports",\r\n  });\r\n\r\n  const nextId = await category.generateNextId();\r\n\r\n  console.log(nextId); // 512344\r\n  console.log(category.id); // 512344\r\n}\r\n\r\nmain();\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This will generate the next id and assign it to the ",(0,r.jsx)(n.code,{children:"id"})," property of the model."]}),"\n",(0,r.jsx)(n.h2,{id:"timestamps",children:"Timestamps"}),"\n",(0,r.jsxs)(n.p,{children:["By default, when saving a new model, the ",(0,r.jsx)(n.code,{children:"createdAt"})," and ",(0,r.jsx)(n.code,{children:"updatedAt"})," properties will be set to the current date, if the model is being saved as ",(0,r.jsx)(n.code,{children:"update"})," then only the ",(0,r.jsx)(n.code,{children:"updatedAt"})," property will be set to the current date."]}),"\n",(0,r.jsx)(n.p,{children:"You can change the name of timestamp columns in the model, let's take an example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/models/category.ts"',children:'import { Model } from "@warlock.js/cascade";\r\n\r\nexport class User extends Model {\r\n  /**\r\n   * The collection name\r\n   */\r\n  public static collection = "users";\r\n\r\n  /**\r\n   * {@inheritDoc}\r\n   */\r\n  public createdAtColumn = "createdAt";\r\n\r\n  /**\r\n   * {@inheritDoc}\r\n   */\r\n  public updatedAtColumn = "updatedAt";\r\n\r\n  /**\r\n   * {@inheritDoc}\r\n   */\r\n  public deletedAtColumn = "deletedAt";\r\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"These are the default values, so if you want to change the name of the columns, you can override these properties."}),"\n",(0,r.jsx)(n.h2,{id:"upsert",children:"Upsert"}),"\n",(0,r.jsxs)(n.p,{children:["In some situations, we need to update a model if it exists or create a new one if it doesn't exist, to achieve this we can use the ",(0,r.jsx)(n.code,{children:"upsert"})," method, let's take an example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/app.ts"',children:'import { Category } from "./models/category";\r\n\r\nasync function main() {\r\n  const category = await Category.upsert(\r\n    {\r\n      name: "Sports",\r\n    },\r\n    {\r\n      name: "Sports",\r\n      isActive: true,\r\n    }\r\n  );\r\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["So here we are trying to find a category with the name ",(0,r.jsx)(n.code,{children:"Sports"}),", if it exists then it will update it, if it doesn't exist then it will create a new one."]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["The first argument is the ",(0,r.jsx)(n.code,{children:"filter"})," object to search for the model, the second argument is the data to update or create the model with."]})}),"\n",(0,r.jsx)(n.p,{children:"This will create a new model if it doesn't exist or update it if it exists."}),"\n",(0,r.jsx)(n.h2,{id:"a-note-about-saving-models",children:"A note about saving models"}),"\n",(0,r.jsxs)(n.p,{children:["Please note that when calling ",(0,r.jsx)(n.code,{children:"save"})," or ",(0,r.jsx)(n.code,{children:"silentSaving"})," methods, the document in the database will be fully replaced, not updating the available fields, the entire document will be changed."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var r=t(6540);const s={},a=r.createContext(s);function o(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);