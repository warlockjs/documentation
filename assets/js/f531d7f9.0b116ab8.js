"use strict";(self.webpackChunkmongez_docs=self.webpackChunkmongez_docs||[]).push([[2653],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),u=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},h=function(e){var t=u(e.components);return a.createElement(i.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,i=e.parentName,h=o(e,["components","mdxType","originalType","parentName"]),p=u(n),g=r,d=p["".concat(i,".").concat(g)]||p[g]||c[g]||l;return n?a.createElement(d,s(s({ref:t},h),{},{components:n})):a.createElement(d,s({ref:t},h))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,s=new Array(l);s[0]=g;var o={};for(var i in t)hasOwnProperty.call(t,i)&&(o[i]=t[i]);o.originalType=e,o[p]="string"==typeof e?e:r,s[1]=o;for(var u=2;u<l;u++)s[u]=n[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},8011:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>s,default:()=>c,frontMatter:()=>l,metadata:()=>o,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const l={sidebar_position:4},s="Filtering",o={unversionedId:"cascade/aggregate/filtering",id:"cascade/aggregate/filtering",title:"Filtering",description:"Perform filtering on your data using the where methods.",source:"@site/docs/cascade/aggregate/filtering.mdx",sourceDirName:"cascade/aggregate",slug:"/cascade/aggregate/filtering",permalink:"/docs/cascade/aggregate/filtering",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"mongodb",previous:{title:"Selecting Columns / Projecting",permalink:"/docs/cascade/aggregate/selecting-columns"},next:{title:"$agg",permalink:"/docs/cascade/aggregate/agg"}},i={},u=[{value:"where",id:"where",level:2},{value:"Simple where stage",id:"simple-where-stage",level:3},{value:"Where with operator",id:"where-with-operator",level:3},{value:"Where with object",id:"where-with-object",level:3},{value:"Where null",id:"where-null",level:2},{value:"Where not null",id:"where-not-null",level:2},{value:"Where in",id:"where-in",level:2},{value:"Where not in",id:"where-not-in",level:2},{value:"Where between",id:"where-between",level:2},{value:"Where not between",id:"where-not-between",level:2},{value:"Where like",id:"where-like",level:2},{value:"Where not like",id:"where-not-like",level:2},{value:"Where starts with",id:"where-starts-with",level:2},{value:"Where not starts with",id:"where-not-starts-with",level:2},{value:"Where ends with",id:"where-ends-with",level:2},{value:"Where not ends with",id:"where-not-ends-with",level:2},{value:"Where date between",id:"where-date-between",level:2},{value:"Where date not between",id:"where-date-not-between",level:2},{value:"Where exists",id:"where-exists",level:2},{value:"Where not exists",id:"where-not-exists",level:2},{value:"Where near",id:"where-near",level:2},{value:"Or Where",id:"or-where",level:2},{value:"Where Columns",id:"where-columns",level:2}],h={toc:u},p="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"filtering"},"Filtering"),(0,r.kt)("p",null,"Perform filtering on your data using the ",(0,r.kt)("inlineCode",{parentName:"p"},"where")," methods."),(0,r.kt)("p",null,"Mongez Aggregate class provides various methods to filter your data."),(0,r.kt)("h2",{id:"where"},"where"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"where")," method is used to filter documents based on a condition. It could take multiple forms:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Add where stage\n   */\n  public where(column: string, value: any): this;\n  public where(column: string, operator: WhereOperator, value: any): this;\n  public where(column: Record<string, any>): this;\n")),(0,r.kt)("p",null,"Let's have a look at each one of them:"),(0,r.kt)("h3",{id:"simple-where-stage"},"Simple where stage"),(0,r.kt)("p",null,"If you just want to filter documents based on a single value equality, you can do this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const users = await aggregate.where("id", 10).get();\n')),(0,r.kt)("p",null,"Just pass the column name and the value you want to filter by."),(0,r.kt)("h3",{id:"where-with-operator"},"Where with operator"),(0,r.kt)("p",null,"Alternatively, if you want to make more conditions, you can use the operator, here are the available operators:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const whereOperators = [\n  "=",\n  "!=",\n  "not",\n  ">",\n  ">=",\n  "<",\n  "<=",\n  "in",\n  "nin",\n  "notIn",\n  "all",\n  "exists",\n  "type",\n  "mod",\n  "regex",\n  "geoIntersects",\n  "geoWithin",\n  "near",\n  "between",\n  "notBetween",\n  "nearSphere",\n  "elemMatch",\n  "size",\n  "like",\n  "notLike",\n  "startsWith",\n  "endsWith",\n];\n')),(0,r.kt)("p",null,"It could be any of the previous operators, let's take some examples:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const users = await aggregate.where("id", ">", 10).get();\nconst users = await aggregate.where("id", "in", [1, 2, 3]).get();\nconst users = await aggregate.where("id", "between", [1, 10]).get();\n')),(0,r.kt)("h3",{id:"where-with-object"},"Where with object"),(0,r.kt)("p",null,"Another way to filter documents is to pass an object to the ",(0,r.kt)("inlineCode",{parentName:"p"},"where")," method, this object should have the column name as a key, and the value should be the value you want to filter by."),(0,r.kt)("p",null,"Method signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"public where(column: Record<string, any>): this;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const users = await aggregate.where({ id: 10 }).get();\n")),(0,r.kt)("p",null,"You can also use the built-in Mongodb operators:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const users = await aggregate.where({ id: { $gt: 10 } }).get();\n")),(0,r.kt)("admonition",{title:"Did you know?",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"You can use ",(0,r.kt)("a",{parentName:"p",href:"./agg"},"$agg utility")," to easily use built-in operators directly.")),(0,r.kt)("h2",{id:"where-null"},"Where null"),(0,r.kt)("p",null,"If you want to filter documents based on a null value, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"whereNull")," method:"),(0,r.kt)("p",null,"Method signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"public whereNull(column: string): this;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const users = await aggregate.whereNull("id").get();\n')),(0,r.kt)("p",null,"This will return all users that have ",(0,r.kt)("inlineCode",{parentName:"p"},"id = null"),"."),(0,r.kt)("h2",{id:"where-not-null"},"Where not null"),(0,r.kt)("p",null,"If you want to filter documents based on a not null value, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"whereNotNull")," method:"),(0,r.kt)("p",null,"Method signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"public whereNotNull(column: string): this;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const users = await aggregate.whereNotNull("id").get();\n')),(0,r.kt)("h2",{id:"where-in"},"Where in"),(0,r.kt)("p",null,"If you want to filter documents based on a list of values, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"whereIn")," method:"),(0,r.kt)("p",null,"Method signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"public whereIn(column: string, value: any[]): this;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const users = await aggregate.whereIn("id", [1, 2, 3]).get();\n')),(0,r.kt)("p",null,"If the second argument is a string, then it will be treated as a ",(0,r.kt)("inlineCode",{parentName:"p"},"column name"),"."),(0,r.kt)("h2",{id:"where-not-in"},"Where not in"),(0,r.kt)("p",null,"If you want to filter documents based on a list of values, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"whereNotIn")," method:"),(0,r.kt)("p",null,"Method signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"public whereNotIn(column: string, value: any[]): this;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const users = await aggregate.whereNotIn("id", [1, 2, 3]).get();\n')),(0,r.kt)("p",null,"If the second argument is a string, then it will be treated as a ",(0,r.kt)("inlineCode",{parentName:"p"},"column name"),"."),(0,r.kt)("h2",{id:"where-between"},"Where between"),(0,r.kt)("p",null,"If you want to filter documents based on a range of values, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"whereBetween")," method:"),(0,r.kt)("p",null,"Method signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"public whereBetween(column: string, value: [any, any]): this;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const users = await aggregate.whereBetween("id", [1, 10]).get();\n')),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"The second argument is an array of two values, the first value is the ",(0,r.kt)("inlineCode",{parentName:"p"},"min")," value, and the second value is the ",(0,r.kt)("inlineCode",{parentName:"p"},"max")," value and they are both included in the range.")),(0,r.kt)("h2",{id:"where-not-between"},"Where not between"),(0,r.kt)("p",null,"If you want to filter documents based on a range of values, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"whereNotBetween")," method:"),(0,r.kt)("p",null,"Method signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"public whereNotBetween(column: string, value: [any, any]): this;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const users = await aggregate.whereNotBetween("id", [1, 10]).get();\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"The second argument is an array of two values, the first value is the ",(0,r.kt)("inlineCode",{parentName:"p"},"min")," value, and the second value is the ",(0,r.kt)("inlineCode",{parentName:"p"},"max")," value and they are both included in the range.")),(0,r.kt)("h2",{id:"where-like"},"Where like"),(0,r.kt)("p",null,"If you want to filter documents based on a string pattern, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"whereLike")," method:"),(0,r.kt)("p",null,"Method signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"public whereLike(column: string, value: string): this;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const users = await aggregate.whereLike("name", "John").get();\n')),(0,r.kt)("p",null,"This will return all users that have ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," column that contains ",(0,r.kt)("inlineCode",{parentName:"p"},"John"),"."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"If the second argument is a string, the value will be case-insensitive.")),(0,r.kt)("p",null,"You can also pass a ",(0,r.kt)("inlineCode",{parentName:"p"},"regex")," object:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const users = await aggregate.whereLike("name", /John/i).get();\n')),(0,r.kt)("h2",{id:"where-not-like"},"Where not like"),(0,r.kt)("p",null,"If you want to filter documents based on a string pattern, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"whereNotLike")," method:"),(0,r.kt)("p",null,"Method signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"public whereNotLike(column: string, value: string): this;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const users = await aggregate.whereNotLike("name", "John").get();\n')),(0,r.kt)("p",null,"This will return all users that have ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," column that does not contain ",(0,r.kt)("inlineCode",{parentName:"p"},"John"),"."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"If the second argument is a string, the value will be case-insensitive.")),(0,r.kt)("h2",{id:"where-starts-with"},"Where starts with"),(0,r.kt)("p",null,"If you want to filter documents based on a string pattern, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"whereStartsWith")," method:"),(0,r.kt)("p",null,"Method signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"public whereStartsWith(column: string, value: string): this;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const users = await aggregate.whereStartsWith("name", "John").get();\n')),(0,r.kt)("p",null,"This will return all users that have ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," column that starts with ",(0,r.kt)("inlineCode",{parentName:"p"},"John"),"."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"The value will be case-sensitive.")),(0,r.kt)("h2",{id:"where-not-starts-with"},"Where not starts with"),(0,r.kt)("p",null,"Search for documents that a column does not start with a given value."),(0,r.kt)("p",null,"Method signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"public whereNotStartsWith(column: string, value: string): this;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const users = await aggregate.whereNotStartsWith("name", "John").get();\n')),(0,r.kt)("h2",{id:"where-ends-with"},"Where ends with"),(0,r.kt)("p",null,"If you want to filter documents based on a string pattern, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"whereEndsWith")," method:"),(0,r.kt)("p",null,"Method signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"public whereEndsWith(column: string, value: string): this;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const users = await aggregate.whereEndsWith("name", "John").get();\n')),(0,r.kt)("p",null,"This will return all users that have ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," column that ends with ",(0,r.kt)("inlineCode",{parentName:"p"},"John"),"."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"The value will be case-sensitive.")),(0,r.kt)("h2",{id:"where-not-ends-with"},"Where not ends with"),(0,r.kt)("p",null,"Search for documents that a column does not end with a given value."),(0,r.kt)("p",null,"Method signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"public whereNotEndsWith(column: string, value: string): this;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const users = await aggregate.whereNotEndsWith("name", "John").get();\n')),(0,r.kt)("h2",{id:"where-date-between"},"Where date between"),(0,r.kt)("p",null,"If you want to filter documents based on a date range, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"whereDateBetween")," method:"),(0,r.kt)("p",null,"Method signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"public whereDateBetween(column: string, value: [Date, Date]): this;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const users = await aggregate\n  .whereDateBetween("createdAt", [\n    new Date("2020-01-01"),\n    new Date("2020-12-31"),\n  ])\n  .get();\n')),(0,r.kt)("h2",{id:"where-date-not-between"},"Where date not between"),(0,r.kt)("p",null,"Filter documents that are not between a date range."),(0,r.kt)("p",null,"Method signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"public whereDateNotBetween(column: string, value: [Date, Date]): this;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const users = await aggregate\n  .whereDateNotBetween("createdAt", [\n    new Date("2020-01-01"),\n    new Date("2020-12-31"),\n  ])\n  .get();\n')),(0,r.kt)("h2",{id:"where-exists"},"Where exists"),(0,r.kt)("p",null,"This method will filter documents based on the existence of a column."),(0,r.kt)("p",null,"Method signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"public whereExists(column: string): this;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const users = await aggregate.whereExists("name").get();\n')),(0,r.kt)("h2",{id:"where-not-exists"},"Where not exists"),(0,r.kt)("p",null,"This method will filter documents based on the existence of a column."),(0,r.kt)("p",null,"Method signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"public whereNotExists(column: string): this;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const users = await aggregate.whereNotExists("name").get();\n')),(0,r.kt)("h2",{id:"where-near"},"Where near"),(0,r.kt)("p",null,"This method will filter documents based on the distance between two points."),(0,r.kt)("h2",{id:"or-where"},"Or Where"),(0,r.kt)("p",null,"If we need to filter if any of the conditions is true, we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"orWhere")," method."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const users = await aggregate\n  .orWhere({\n    id: 10,\n    name: "John",\n  })\n  .get();\n')),(0,r.kt)("p",null,"This will return all users that have either ",(0,r.kt)("inlineCode",{parentName:"p"},"id = 10")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"name = John"),"."),(0,r.kt)("p",null,"You can also use the ",(0,r.kt)("a",{parentName:"p",href:"./agg"},"$agg utility")," to use built-in operators:"),(0,r.kt)("p",null,"Before:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const users = await aggregate\n  .orWhere({\n    id: { $gt: 10 },\n    name: { $regex: /john/i },\n  })\n  .get();\n")),(0,r.kt)("p",null,"After:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { $agg } from "@warlock.js/cascade";\n\nconst users = await aggregate\n  .orWhere({\n    id: $agg.gt(10),\n    name: $agg.like("john"),\n  })\n  .get();\n')),(0,r.kt)("h2",{id:"where-columns"},"Where Columns"),(0,r.kt)("p",null,"If we need to compare values between two columns or more, we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"whereColumns")," method."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const users = await aggregate\n  .whereColumns("maxAddresses", ">", "addressesCount")\n  .get();\n')),(0,r.kt)("p",null,"This will return all users that have ",(0,r.kt)("inlineCode",{parentName:"p"},"maxAddresses")," column greater than ",(0,r.kt)("inlineCode",{parentName:"p"},"addressesCount")," column."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"The second argument is the operator, it could be any of the ",(0,r.kt)("a",{parentName:"p",href:"#where-with-operator"},"where operators")," and it is always required.")))}c.isMDXComponent=!0}}]);