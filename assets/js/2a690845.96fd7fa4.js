"use strict";(self.webpackChunkmongez_docs=self.webpackChunkmongez_docs||[]).push([[8866],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>g});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var r=o.createContext({}),p=function(e){var t=o.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return o.createElement(r.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,r=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(n),u=a,g=m["".concat(r,".").concat(u)]||m[u]||d[u]||i;return n?o.createElement(g,s(s({ref:t},c),{},{components:n})):o.createElement(g,s({ref:t},c))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=u;var l={};for(var r in t)hasOwnProperty.call(t,r)&&(l[r]=t[r]);l.originalType=e,l[m]="string"==typeof e?e:a,s[1]=l;for(var p=2;p<i;p++)s[p]=n[p];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2340:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var o=n(7462),a=(n(7294),n(3905));const i={sidebar_position:4},s="Joins (Lookups)",l={unversionedId:"cascade/relationships/joins",id:"cascade/relationships/joins",title:"Joins (Lookups)",description:"Joins mean data is fetched from two or more collections in one query, for example, fetching posts, each post has a user id, and we want to fetch the user data for each post.",source:"@site/docs/cascade/relationships/joins.mdx",sourceDirName:"cascade/relationships",slug:"/cascade/relationships/joins",permalink:"/docs/cascade/relationships/joins",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"mongodb",previous:{title:"Syncing Models",permalink:"/docs/cascade/relationships/syncing-models"},next:{title:"Advanced",permalink:"/docs/category/advanced-1"}},r={},p=[{value:"The joinings method",id:"the-joinings-method",level:2},{value:"Joinings",id:"joinings",level:2},{value:"1-1 Relationship",id:"1-1-relationship",level:2},{value:"1-many Relationship",id:"1-many-relationship",level:2},{value:"Using Joinings",id:"using-joinings",level:2},{value:"Joining Options",id:"joining-options",level:2},{value:"Auto Detecting Fields",id:"auto-detecting-fields",level:2},{value:"Counting Joined Documents",id:"counting-joined-documents",level:2},{value:"Using Aggregate pipeline",id:"using-aggregate-pipeline",level:2},{value:"Example",id:"example",level:3},{value:"Advanced Examples",id:"advanced-examples",level:2},{value:"Counting Likes and Comments for only current user",id:"counting-likes-and-comments-for-only-current-user",level:3},{value:"Get total likes and check if current user liked the post",id:"get-total-likes-and-check-if-current-user-liked-the-post",level:3}],c={toc:p},m="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(m,(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"joins-lookups"},"Joins (Lookups)"),(0,a.kt)("p",null,"Joins mean data is fetched from two or more collections in one query, for example, fetching posts, each post has a user id, and we want to fetch the user data for each post."),(0,a.kt)("p",null,"Or we may fetch multiple documents, for example, fetch comments when fetching posts."),(0,a.kt)("p",null,"This could be done in MongoDB using ",(0,a.kt)("a",{parentName:"p",href:"https://docs.mongodb.com/manual/reference/operator/aggregation/lookup/"},"Lookups"),"."),(0,a.kt)("p",null,"But in Monpulse, we have a better way to do it."),(0,a.kt)("h2",{id:"the-joinings-method"},"The joinings method"),(0,a.kt)("p",null,"Any model has its own ",(0,a.kt)("a",{parentName:"p",href:"/docs/cascade/aggregate/model-aggregate"},"Aggregate model class"),", the idea here is to make the code more readable and easier to maintain."),(0,a.kt)("p",null,"Let's take an example of the basic lookup pipeline and see how we can transform it into a more readable code."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { Post } from "./models/post";\n\nconst posts = await Post.aggregate()\n  .lookup({\n    from: "comments",\n    localField: "id",\n    foreignField: "post.id",\n    as: "comments",\n  })\n  .get();\n')),(0,a.kt)("p",null,"This will fetch all posts and join the user data for each post, which gives an output like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "id": "1",\n    "title": "Post 1",\n    "createdBy": {\n      "id": "2",\n      "name": "User 1",\n      "image": "path-to-image.jpg"\n    },\n    "comments": [\n      {\n        "id": "1",\n        "content": "Comment 1",\n        "createdBy": {\n          "id": "3",\n          "name": "User 2",\n          "image": "path-to-image.jpg"\n        }\n      },\n      {\n        "id": "2",\n        "content": "Comment 2",\n        "createdBy": {\n          "id": "4",\n          "name": "User 3",\n          "image": "path-to-image.jpg"\n        }\n      }\n    ]\n  }\n]\n')),(0,a.kt)("h2",{id:"joinings"},"Joinings"),(0,a.kt)("p",null,"So the concept is simple, we define a list of static ",(0,a.kt)("inlineCode",{parentName:"p"},"joinings")," in the model, each joining has a name, and a ",(0,a.kt)("inlineCode",{parentName:"p"},"Joinable")," instance."),(0,a.kt)("p",null,"We have two types of joinings, the first one is we want to make a ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/One-to-one_(data_model)"},"1-1 relationship")," between the two collections, and the second one is we want to make a ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/One-to-many_(data_model)"},"1-many relationship"),"."),(0,a.kt)("p",null,"Let's see each one"),(0,a.kt)("h2",{id:"1-1-relationship"},"1-1 Relationship"),(0,a.kt)("p",null,"Let's say we have a ",(0,a.kt)("inlineCode",{parentName:"p"},"Post")," model, and we want to join the user data for each post, we can define a joining like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/models/post.ts"',title:'"src/models/post.ts"'},'import { Model } from "@warlock.js/cascade";\nimport { User } from "./user";\n\nexport class Post extends Model {\n  static collectionName = "posts";\n\n  /**\n   * List of joinings\n   */\n  public static joinings = {\n    author: User.joinable("createdBy.id", "id").single().as("author"),\n  };\n}\n')),(0,a.kt)("p",null,"This will join the user data for each post, and the output will be like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "id": "1",\n    "title": "Post 1",\n    "author": {\n      "id": "2",\n      "name": "User 1",\n      "image": "path-to-image.jpg"\n    }\n  }\n]\n')),(0,a.kt)("p",null,"As it performs a ",(0,a.kt)("a",{parentName:"p",href:"https://docs.mongodb.com/manual/reference/operator/aggregation/lookup/"},"Lookup Pipeline"),", it will return an array of documents, so we need to use the ",(0,a.kt)("inlineCode",{parentName:"p"},"single")," method to tell The Joiner that we want to return only one document."),(0,a.kt)("p",null,"This will make a lookup object with the following properties:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "from": "users",\n  "localField": "createdBy.id",\n  "foreignField": "id",\n  "as": "author"\n}\n')),(0,a.kt)("h2",{id:"1-many-relationship"},"1-many Relationship"),(0,a.kt)("p",null,"Suppose we want to return list of comments for each post, we can define a joining like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/models/post.ts"',title:'"src/models/post.ts"'},'import { Model } from "@warlock.js/cascade";\nimport { Comment } from "./comment";\n\nexport class Post extends Model {\n  static collectionName = "posts";\n\n  /**\n   * List of joinings\n   */\n  public static joinings = {\n    comments: Comment.joinable("id", "post.id"),\n  };\n}\n')),(0,a.kt)("p",null,"This will make a lookup object with the following properties:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "from": "comments",\n  "localField": "id",\n  "foreignField": "post.id",\n  "as": "comments"\n}\n')),(0,a.kt)("p",null,"We can alternatively, use ",(0,a.kt)("inlineCode",{parentName:"p"},"localField")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"foreignField")," properties to define the fields"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/models/post.ts"',title:'"src/models/post.ts"'},'import { Model } from "@warlock.js/cascade";\nimport { User } from "./user";\nimport { Comment } from "./comment";\n\nexport class Post extends Model {\n  static collectionName = "posts";\n\n  /**\n   * List of joinings\n   */\n  public static joinings = {\n    author: User.joinable()\n      .single(true)\n      .localField("createdBy.id")\n      .foreignField("id"),\n    comments: Comment.joinable().localField("id").foreignField("post.id"),\n  };\n}\n')),(0,a.kt)("p",null,"Now let's see how we can use it:"),(0,a.kt)("h2",{id:"using-joinings"},"Using Joinings"),(0,a.kt)("p",null,"To use any of these joinings in a ",(0,a.kt)("a",{parentName:"p",href:"/docs/cascade/aggregate/model-aggregate"},"Model Aggregate")," query, we can use ",(0,a.kt)("inlineCode",{parentName:"p"},"joining")," method which accepts two argument, the first one is the joining name or the ",(0,a.kt)("inlineCode",{parentName:"p"},"Joinable instance"),", the second argument is the ",(0,a.kt)("inlineCode",{parentName:"p"},"options")," object."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { Post } from "./models/post";\n\nconst posts = await Post.aggregate()\n  .joining("author")\n  .joining("comments")\n  .get();\n')),(0,a.kt)("p",null,"We can refer to the reference of the joining directly from the static property ",(0,a.kt)("inlineCode",{parentName:"p"},"joinings"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { Post } from "./models/post";\n\nconst posts = await Post.aggregate()\n  .joining(Post.joinings.author)\n  .joining(Post.joinings.comments)\n  .get();\n')),(0,a.kt)("p",null,"The second solution gives you more flexibility and more typescript support."),(0,a.kt)("h2",{id:"joining-options"},"Joining Options"),(0,a.kt)("p",null,"So now we saw how to perform a lookup using the ",(0,a.kt)("inlineCode",{parentName:"p"},"joining")," method, but what if we want to customize the lookup options?"),(0,a.kt)("p",null,"For example, let's say we want to get only the approved comments with the post not all comments."),(0,a.kt)("p",null,"We can pass the options object as the second argument to the ",(0,a.kt)("inlineCode",{parentName:"p"},"joining")," method:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { Post } from "./models/post";\n\nconst posts = await Post.aggregate()\n  .joining("author")\n  .joining("comments")\n  .get();\n')),(0,a.kt)("p",null,"We may also define what to be selected from the joined collection:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { Post } from "./models/post";\n\nconst posts = await Post.aggregate()\n  .joining("author")\n  .joining("comments", {\n    where: {\n      isApproved: true,\n    },\n    select: ["id", "content"],\n  })\n  .get();\n')),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"These can also be done when declaring the joinings list, but sometimes we want to make more filter based on the current situation.")),(0,a.kt)("p",null,"We can also use the ",(0,a.kt)("inlineCode",{parentName:"p"},"where")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"select")," methods from the joining instance:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{6}","{6}":!0},'import { Post } from "./models/post";\n\nconst posts = await Post.aggregate()\n  .joining("author")\n  .joining(\n    Post.joinings.comments.where({ isApproved: true }).select(["id", "content"])\n  )\n  .joining()\n  .get();\n')),(0,a.kt)("admonition",{title:"Did you know?",type:"info"},(0,a.kt)("p",{parentName:"admonition"},"When using the ",(0,a.kt)("inlineCode",{parentName:"p"},"where")," method from the joining instance, you can use any of the ",(0,a.kt)("a",{parentName:"p",href:"/docs/cascade/aggregate/filtering"},"where operators"))),(0,a.kt)("h2",{id:"auto-detecting-fields"},"Auto Detecting Fields"),(0,a.kt)("p",null,"By default the ",(0,a.kt)("inlineCode",{parentName:"p"},"Joinable")," class will set the local field to ",(0,a.kt)("inlineCode",{parentName:"p"},"id"),"."),(0,a.kt)("p",null,"Regarding ",(0,a.kt)("inlineCode",{parentName:"p"},"as")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"foreignField")," properties, it will depend on the ",(0,a.kt)("inlineCode",{parentName:"p"},"single")," type, if it set to ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),", then it will be the singular of the joining model ",(0,a.kt)("inlineCode",{parentName:"p"},"collection")," value, otherwise it will be the plural of the joining model ",(0,a.kt)("inlineCode",{parentName:"p"},"collection")," value."),(0,a.kt)("p",null,"And the foreign field will be the same as ",(0,a.kt)("inlineCode",{parentName:"p"},"as")," but suffixed with ",(0,a.kt)("inlineCode",{parentName:"p"},"Id"),"."),(0,a.kt)("p",null,"Let's see the both example, the first one if we provided all ",(0,a.kt)("a",{parentName:"p",href:"https://docs.mongodb.com/manual/reference/operator/aggregation/lookup/"},"Lookup")," options:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/models/post.ts"',title:'"src/models/post.ts"'},'import { Model } from "@warlock.js/cascade";\nimport { User } from "./user";\n\nexport class Post extends Model {\n  static collectionName = "posts";\n\n  /**\n   * List of joinings\n   */\n  public static joinings = {\n    author: User.joinable()\n      .single(true)\n      .localField("createdBy.id")\n      .foreignField("id")\n      .as("author"),\n  };\n}\n')),(0,a.kt)("p",null,"Now let's see the second example, if we didn't provide any options:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/models/post.ts"',title:'"src/models/post.ts"'},'import { Model } from "@warlock.js/cascade";\nimport { User } from "./user";\n\nexport class Post extends Model {\n  static collectionName = "posts";\n\n  /**\n   * List of joinings\n   */\n  public static joinings = {\n    author: User.joinable().single(true),\n  };\n}\n')),(0,a.kt)("p",null,"This will be translated to:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { Model } from "@warlock.js/cascade";\nimport { User } from "./user";\n\nexport class Post extends Model {\n  static collectionName = "posts";\n\n  /**\n   * List of joinings\n   */\n  public static joinings = {\n    author: User.joinable()\n      .single(true)\n      .localField("user.id")\n      .foreignField("id")\n      .as("user"),\n  };\n}\n')),(0,a.kt)("p",null,"It is pretty near to be accurate, but if the user that is stored in the ",(0,a.kt)("inlineCode",{parentName:"p"},"Post")," model is ",(0,a.kt)("inlineCode",{parentName:"p"},"createdBy"),", then we need to change the ",(0,a.kt)("inlineCode",{parentName:"p"},"localField")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"createdBy.id"),":"),(0,a.kt)("p",null,"You could also pass the four values as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/models/post.ts"',title:'"src/models/post.ts"'},'import { Model } from "@warlock.js/cascade";\nimport { User } from "./user";\n\nexport class Post extends Model {\n  static collectionName = "posts";\n\n  /**\n   * List of joinings\n   */\n  public static joinings = {\n    author: User.joinable("createdBy.id", "id", true, "author"),\n  };\n}\n')),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"calling ",(0,a.kt)("inlineCode",{parentName:"p"},"single")," method with ",(0,a.kt)("strong",{parentName:"p"},"true")," value will only return one document, otherwise it will return list of documents from the joined collection, default value to ",(0,a.kt)("inlineCode",{parentName:"p"},"single")," is ",(0,a.kt)("strong",{parentName:"p"},"false"),".")),(0,a.kt)("h2",{id:"counting-joined-documents"},"Counting Joined Documents"),(0,a.kt)("p",null,"Sometimes we just need to count the documents from the joined collection, for example we need to count total number of comments for each post, in that situation we can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"countJoining")," method:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { Post } from "./models/post";\n\nconst posts = await Post.aggregate().countJoining("comments").get();\n')),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Please note that the first and second argument of the ",(0,a.kt)("inlineCode",{parentName:"p"},"countJoining")," method are the same as the ",(0,a.kt)("inlineCode",{parentName:"p"},"joining")," method.")),(0,a.kt)("p",null,"This will return a new property called ",(0,a.kt)("inlineCode",{parentName:"p"},"commentsCount")," for each post, if you want to set a custom name for the property, you can pass the ",(0,a.kt)("inlineCode",{parentName:"p"},"as")," property in the options object:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { Post } from "./models/post";\n\nconst posts = await Post.aggregate()\n  .countJoining("comments", {\n    as: "totalComments",\n  })\n  .get();\n')),(0,a.kt)("h2",{id:"using-aggregate-pipeline"},"Using Aggregate pipeline"),(0,a.kt)("p",null,"So if we need to add more pipeline options to the joining (lookup) collection, we can use the second argument to the ",(0,a.kt)("inlineCode",{parentName:"p"},"joining")," method, it receives a callback function which receives the ",(0,a.kt)("inlineCode",{parentName:"p"},"Joinable")," instance for the joined collection, which we can use any ",(0,a.kt)("a",{parentName:"p",href:"./../aggregate/introduction"},"Aggregate")," method on it."),(0,a.kt)("h3",{id:"example"},"Example"),(0,a.kt)("p",null,"This will be the default setup to join comments for the post:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { Model } from "@warlock.js/cascade";\nimport { Post } from "./models/post";\nimport { Comment } from "./models/comment";\n\nexport class Post extends Model {\n  static collectionName = "posts";\n\n  /**\n   * List of joinings\n   */\n  public static joinings = {\n    comments: Comment.joinable("id", "post.id"),\n  };\n}\n')),(0,a.kt)("p",null,"Now we can get all comments for the post like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { Post } from "./models/post";\n\nconst posts = await Post.aggregate().joining("comments").get();\n')),(0,a.kt)("p",null,"Or we can get only the approved comments:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { Post } from "./models/post";\n\nconst posts = await Post.aggregate()\n  .joining("comments", (query) => query.where("isApproved", true))\n  .get();\n')),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"The query used here will be on the joined collection, which will be applied on the ",(0,a.kt)("inlineCode",{parentName:"p"},"comments")," collection.")),(0,a.kt)("h2",{id:"advanced-examples"},"Advanced Examples"),(0,a.kt)("p",null,"We have ",(0,a.kt)("inlineCode",{parentName:"p"},"Post")," model, represents ",(0,a.kt)("strong",{parentName:"p"},"posts collection"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Comment")," model represents ",(0,a.kt)("strong",{parentName:"p"},"comments collection")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Like")," model represents ",(0,a.kt)("strong",{parentName:"p"},"likes collection"),"."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Like")," model has two properties, ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"typeId"),", so we can store inside it post and/or comment likes."),(0,a.kt)("p",null,"Let's see how we can fetch the posts with the comments and likes count for each post:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"models/post.ts {11}","models/post.ts":!0,"{11}":!0},'import { Model } from "@warlock.js/cascade";\nimport { Like } from "./like";\nimport { Comment } from "./comment";\n\nexport class Post extends Model {\n  static collectionName = "posts";\n\n  /**\n   * List of joinings\n   */\n  public static joinings = {\n    likes: Like.joinable("id", "type.id").where("type", "post"),\n    comments: Comment.joinable("id", "post.id"),\n  };\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"models/like.ts","models/like.ts":!0},'import { Model, Casts } from "@warlock.js/cascade";\n\nexport class Like extends Model {\n  static collectionName = "likes";\n\n  /**\n   * {@inheritDoc}\n   */\n  protected casts: Casts = {\n    type: "string",\n    typeId: "int",\n  };\n}\n')),(0,a.kt)("p",null,"Now let's count the comments and likes for each post:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { Post } from "./models/post";\n\nconst posts = await Post.aggregate()\n  .countJoining("likes")\n  .countJoining("comments")\n  .get();\n')),(0,a.kt)("p",null,"This will return something like this: (I'm using ",(0,a.kt)("inlineCode",{parentName:"p"},"console.log")," to make it more readable)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "id": "1",\n    "title": "Post 1",\n    "likesCount": 2,\n    "commentsCount": 2\n  }\n]\n')),(0,a.kt)("h3",{id:"counting-likes-and-comments-for-only-current-user"},"Counting Likes and Comments for only current user"),(0,a.kt)("p",null,"Let's say we want to count the likes and comments for only the current user, we can do it like this:"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"We'll assume any like or comment has a ",(0,a.kt)("inlineCode",{parentName:"p"},"createdBy")," object of a ",(0,a.kt)("inlineCode",{parentName:"p"},"User")," model.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { Post } from "./models/post";\n\nconst posts = await Post.aggregate()\n  .countJoining("likes", query => query.where(\'createdBy.id\', 1))\n  .countJoining("comments", query => query.where("createdBy.id": 1))\n  .get();\n')),(0,a.kt)("p",null,"This will return something like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "id": "1",\n    "title": "Post 1",\n    "likesCount": 1,\n    "commentsCount": 1\n  }\n]\n')),(0,a.kt)("p",null,"In that scenario we only returned the likes and comments for the current user."),(0,a.kt)("h3",{id:"get-total-likes-and-check-if-current-user-liked-the-post"},"Get total likes and check if current user liked the post"),(0,a.kt)("p",null,"Let's say we want to get the total likes for each post, and check if the current user liked the post or not."),(0,a.kt)("p",null,"We can do it like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { $agg } from "@warlock.js/cascade";\nimport { Post } from "./models/post";\n\nconst posts = await Post.aggregate()\n  .countJoining("likes")\n  .joining("likes", join => join.where("createdBy.id", 1).single(true).as("userLike"))\n  .addField(\'liked\', $agg.booleanCond($agg.eq("$userLike", null))\n  .get();\n')))}d.isMDXComponent=!0}}]);